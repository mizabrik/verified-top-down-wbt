%!TEX TS-program = xelatex
\documentclass[a4paper,14pt]{extarticle}

\input{preamble}

\usepackage[backend=biber,sorting=nty]{biblatex}
\addbibresource{library.bib}

\usepackage{subcaption}

\usepackage{minted}
\setminted{fontsize=\footnotesize}
\newminted{coq}{gobble=0}
\newmintinline{coq}{}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{forest}

\begin{document}

Деревья с балансировкой по весу ---
параметризованное семейство
самобалансирующихся деверьев поиска,
широко применяющееся в функциональном программировании.
Для них существует однопроходная версия алгоритмов модификации,
более быстрая, но менее изученная,
особенно в вопросе допустимых значений параметров.
В данной работе предложена
верифицированная в Coq
реализация операции вставки ключа и
формально доказана допустимость
нескольких практически значимых значений параметров.
Для некоторых из них установление корректности
является новым результатом
даже с учётом неформальных доказательств.

\clearpage
\tableofcontents

\clearpage
\anonsection{Введение}

Формальная верификация ---
доказательство в рамках некоторой формальной системы 
соответствия программы её спецификации ---
становится тем важнее, чем большую роль
в жизни человека начинают играть компьютерные системы.
Вместе с развитием инструментов,
возрастает и их применение в индустрии,
даже компания Facebook
отказалась от слогана <<Move Fast and Break Things>>\cite{breakThings}
и стала применять отдельные методы формальной верификации\cite{facebook}.
Программные ошибки становились причиной
крушения космических кораблей\cite{mco-report}
и гибели пациентов\cite{therac};
нет смысла пытаться перечислить случаи
сбоев или утечек персональных данных
в широко используемых сервисах.
Особенно важно верифицировать алгоритмы
со сложным доказательством корректности, поскольку
ошибки могут появиться не только в их реализации,
но и в самих доказательствах.

Coq\cite{coq}\cite{coqart} --- система для работы с формальными доказательствами,
основанная на соответствии Карри--Ховарда.
Она широко применяется для верификации программного обеспечения,
к ярким образцам можно отнести
верифицированный компилятор C CompCert\cite{compcert}
и верификацию реализации HMAC для SHA-256 в OpenSSL\cite{hmac}
(не только соответствия программы протоколу,
но и криптографических свойств самого протокола).
Возможно и доказательство чисто математических утверждений:
к примеру, с помощью Coq была формализована
основная теорема алгебры\cite{fta}.

Дерево, сбалансированные по весу (далее WBT), --- достаточно популярный вид
самобалансирующихся двоичных деревьев поиска,
впервые представленный Невергельтом и Рейнгольдом\cite{nievergelt};
для поддержания баланса после модификаций они использовали
те же вращения, что и в АВЛ-дереве\cite{avl},
но выполняли их ещё на спуске от корня к изменяемому узлу.
Однако в их алгоритме содержались существенные ошибки,
и классическим стал алгоритм модификации,
предложенный Блумом и Мельхорном\cite{blum},
с отдельным проходом от узла к корню для балансировки.
Позже Лэй и Вуд представили исправленный
однопроходный алгоритм модификации
вместе с детальным доказательством корректности\cite{lai},
но их работа долгое время оставалась незамеченной.
Только спустя почти 30 лет на неё обратили внимание
Барт и Вагнер;
проведя эмпирический анализ, они обнаружили
значительное (от 23\%) улучшение производительности
по сравнению с двухпроходным вариантом в практической задаче из сферы энергетики,
в некоторых синтетических тестах
результаты даже оказались лучше, чем у красно-чёрных деревьев\cite{barth}.

В Haskell, WBT используется как основа для
де-факто стандартных контейнеров \coqinline{Data.Set} и \coqinline{Data.Map}.
В 2010 году в них была обнаружена ошибка:
использование недопустимых значений параметров
(алгоритм допускает настройку степени сбалансированности дерева,
в том числе и в однопроходной версии)
приводило к разбалансировке дерева.
Хираи и Ямамото подошли к исправлению этой ошибки фундаментально ---
они определили вид множества допустимых параметров
и формально доказали с помощью Coq его полноту и корректность\cite{hirai}.
Основываясь на их работе,
Нипков и Дирикс разработали в Isabelle,
другой системе для работы с формальными доказательствами,
верифицированную (в том числе и на соответствие требованиям к деревьям поиска)
реализацию WBT\cite{nipkow}.
Всё это относится исключительно
к двухпроходному варианту алгоритма,
сказать что-либо о корректности алгоритма и допустимости параметров
для однопроходной версии это не позволяет.

Целью данной работы является
разработка и верификация средствами Coq
реализации однопроходной версии алгоритма модификации WBT
и исследование множества допустимых параметров.

\clearpage
\section{Описание алгоритма}

Существует два подхода
к определению деревьев с балансировкой по весу:
с использованием функции баланса и
без, напрямую через размеры поддеревьев.
Первый подход чаще
применяется в публикациях с фокусом на теоретическом аспекте,
поскольку располагает к большей краткости,
а второй --- в публикациях,
освещающих скорее вопрос программирования алгоритма,
поскольку отражает код эффективных реализаций.
В рамках этого раздела
будет использован первый подход,
чтобы как можно быстрее познакомить читателя с алгоритмом,
но в конце будет описан и второй,
который будет применяться далее.

Пусть \( T \) --- двоичное дерево,
и  если оно непусто, то
\( T_l \) и \( T_r \) ---
его левое и правое поддеревья, соответственно.
Обозначая количество узлов в дереве как \( |T| \),
определим функции \emph{веса} и \emph{баланса}:
\begin{equation}
  w(T) = 1 + |W|, \qquad
  \beta(T) = \frac{w(T_l)}{w(T)}.
\end{equation}
При зафиксированном \( \alpha \in [0, 1/2] \),
дерево \( T \) называется
\emph{деревом с ограниченным балансом}
(множество таких деревьев обозначим \( BB_\alpha \))
либо если оно пусто,
либо если \( T_l, T_r \in BB(\alpha) \),
и
\begin{equation}
  \label{eqn:beta}
  \alpha \leqslant \beta(T) \leqslant 1 - \alpha.
\end{equation}
Более известным названием,
особенно в смысле структуры данных,
является <<\emph{дерево, сбалансированное по весу}>>.
Важным свойством,
позволяющим использовать такие деревья
как основу для эффективной реализации
абстрактных типов данных <<множество>> и <<ассоциативный массив>>,
является то, что их высота не превосходит\cite{nievergelt}
\begin{equation}
  \frac{\log (n + 1) - 1}{\log 1/(1 - \alpha)}.
\end{equation}

Если дерево поиска \( T \)
принадлежит \( BB_\alpha \),
то для некоторых значений \( \alpha \)
дерево \( T' \),
полученное из \( T \) вставкой или удалением одного ключа,
можно привести к виду \( BB_\alpha \)
с помощью изображённых на рисунке \ref{pic:rotations}
вращений и их зеркальных отражений.
Один способ, более известный и исследованный,
аналогичен определению операций для АВЛ-дерева.
Сначала выполняется модификация
как для простого дерева поиска,
а после в каждом затронутом узле
выполняется процедура восстановления сбалансированности,
сначала для родителя добавленного или удалённого узла,
потом для родителя родителя,
и так далее, вплоть до корневого узла.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.75]
    \node (T1) {$x$}
      child {
        node {$y$}
          child { node {$T_{ll}$} }
          child { node {$T_{lr}$} }
      }
      child { node (T1r) {$T_r$} }
    ;
    \node (T1') [right=3cm of T1] {$y$}
      child { node  (T1'l) {$T_{ll}$} }
      child {
        node {$x$}
          child { node {$T_{lr}$} }
          child { node {$T_r$} }
      }
    ;
    \node (s1) [right=0cm of T1r] {};
    \node (e1) [left=0cm of T1'l] {};
    \draw [double,->] (s1) -- (e1);
    \node (a) [below right=2cm and 0.4cm of T1r] {(a)};
    
    \node (T2) [above right=0cm and 4cm of T1'] {$x$}
      child {
        node {$y$}
          child { node {$T_{ll}$} }
          child {
            node {$z$}
              child { node {$T_{lrl}$} }
              child { node {$T_{lrr}$} }
          }
      }
      child { node (T2r) {$T_r$} }
    ;
    \node (T2') [below right=0.05cm and 3.5cm of T2] {$z$}
      child [sibling distance=3cm,level 2/.style={sibling distance=1.2cm}] {
        node {$y$}
          child { node {$T_{ll}$} }
          child { node {$T_{lrl}$} }
      }
      child [sibling distance=3cm,level 2/.style={sibling distance=1.2cm}] {
        node {$x$}
          child { node {$T_{lrr}$} }
          child { node {$T_r$} }
      }
    ;
    \node (s2) [below right=0.05cm and 0cm of T2r] {};
    \node (e2) [right=0.9cm of s2] {};
    \draw [double,->] (s2) -- (e2);
    \node (b) [right=7.2cm of a] {(b)};
  \end{tikzpicture}
  \caption{Простое (a) и двойное (b) правые вращения}
  \label{pic:rotations}
\end{figure}

Процедура восстановления сбалансированности
для узла, корня поддерева \( T \), такова:
\begin{itemize}
  \item если \( \beta(T) \in [\alpha, 1 - \alpha] \),
    не делать ничего;
  \item если \( \beta(T) > 1 - \alpha \),
    выполнить одно из вращений,
    изображённых на рисунке \ref{pic:rotations}:
    простое, если \( \beta(T_l) \geqslant 1 - \gamma \),
    или двойное, иначе;
  \item если \( \beta(T) < \alpha \),
    выполнить вращение, зеркальное
    к одному из изображённых на
    рисунке \ref{pic:rotations} вращений:
    простому, если \( \beta(T_r) \leqslant \gamma \),
    или двойному, иначе.
\end{itemize}
\( \gamma \) --- ещё один параметр алгоритма.
Двухпроходная процедура работает корректно
для \( \alpha \in [2/11, 1 - \sqrt{2}/2] \),
в качестве \( \gamma \) можно взять, например,
\( 1/(2 - \alpha) \)\cite{hirai}.

В однопроходном алгоритме модификации
сабалансированность необходимо гарантировать
сбалансированность узла до рекурсивного спуска
в одно из поддеревьев,
когда ещё не известно,
изменится ли множество ключей
(и соответственно, размер поддерева).
Добавляемый ключ может присутствовать,
а удаляемый --- отсутствовать в исходном дереве,
в таком случае модификация называется \emph{избыточной}.
Учёт этого факта требует интуитивно простой конструкции,
которую достаточно трудно определить формально.
Пусть выполняется модификация дерева \( T \),
\( U \) --- некоторое поддерево \( T \).
Пусть операция была выполнена
по алгоритму для простого, не самобалансирующегося
дерева поиска, и при этом не оказалась избыточной,
в результате чего было получено
дерево \( T' \), в котором \( U \) соответствует поддерево \( U' \).
Далее запись \( \beta'(U) \) будет обозначать
значение \( \beta(U') \) в этой гипотетической ситуации.
Например, если вставка или удаление выполняется
для ключа меньшего, чем ключ в корне дерева \( T \),
то для \( T_r \) и всех его поддеревьев
значения \( \beta \) и \( \beta' \) равны;
а для самого \( T \)
\begin{equation}
  \beta'(T) = \begin{cases}
    \frac{w(T_l) + 1}{w(T) + 1}, & \text{если выполняется вставка,} \\
    \frac{w(T_l) - 1}{w(T) - 1}, & \text{если выполняется удаление.}
  \end{cases}
\end{equation}

Чтобы получить однопроходные алгоритмы
вставки и удаления ключа для WBT,
необходимо в алгоритмы для простого дерева поиска
добавить следующую процедуру,
выполняемую перед спуском в поддерево:
\begin{itemize}
  \item если \( \beta'(T) \in [\alpha, 1 - \alpha] \),
    не делать ничего;
  \item если \( \beta'(T) > 1 - \alpha \),
    выполнить одно из вращений,
    изображённых на рисунке \ref{pic:rotations}:
    простое, если \( \max(\beta(T_l), \beta'(T_l)) \geqslant 1 - \gamma \),
    или двойное, иначе;
  \item если \( \beta'(T) < \alpha \),
    выполнить вращение, зеркальное
    к одному из изображённых на
    рисунке \ref{pic:rotations} вращений:
    простому, если \( \min(\beta(T_r), \beta'(T_r)) \leqslant \gamma \),
    или двойному, иначе.
\end{itemize}

Чтобы сложность работы алгоритма была логарифмической,
для каждого узла необходимо хранить размер его поддерева;
но размер модифицируемого дерева нельзя предсказать,
не зная заранее, не окажется ли модификация избыточной.
Поскольку основная мотивация для однопроходного алгоритма ---
избавление от прохода снизу вверх в случае
неизбыточных операций (для избыточных он не требуется и двухпроходном варианте),
сохранённые в узлах размеры поддеревьев обновляются
в предположении неизбыточности операции.
Если же операция оказывается избыточной,
то, чтобы исправить некорретные значения,
всё-таки выполняется обратный проход по дереву.

Что касается альтернативного,
более удобного на практике варианта алгоритма,
единственное отличие состоит в замене
неравенств \ref{eqn:beta} на эквивалентную
систему
\begin{equation}
  \begin{cases}
    w(T_l) \leqslant \Delta \cdot w(T_r), \\
    w(T_r) \leqslant \Delta \cdot w(T_l),
  \end{cases}
\end{equation}
где \( \Delta = (1 - \alpha)/\alpha \).
Аналогичным образом неравенства с \( \gamma \)
заменяются на эквивалентные в терминах
\( \Gamma = \gamma/(1 - \gamma) \).
Далее в работе под параметрами алгоритма
подразумевается пара \( \langle \Delta, \Gamma \rangle \).

\clearpage
\section{Реализация алгоритма в Coq}

Для верификации алгоритма необходимо иметь его реализацию в виде конкретной программы. 
При этом понятие программы может лежать на широком спектре от строки с
символами, которые задают программу на некотором произвольном языке
программирования, вплоть до терма на языке Gallina, лежащего в основе всей
системы. Выбор точки на этом спектре задаёт баланс между, соответственно,
максимально широким пониманием термина <<программа>> и удобством процесса
верификации. С одной стороны, Gallina имеет существенные ограничения: даже
на фоне чисто функциональных языков программирования, существуют дополнительные
ограничения, самое заметное из них --- требование гарантированной остановки любой
программы. Это необходимое требование, поскольку мы используем программы как
доказательства: без такого ограничения любое утверждение можно было бы доказать
простым бесконечным циклом. С другой стороны, чем сильнее мы отдаляемся от обычных термов, тем
больше теории придётся создавать поверх существующего аппарата доказательств.

В рамках данной работы было решено работать
с <<родными>> для Coq'а программами на Gallina,
это позволило сфокусироваться на доказательстве
корректности алгоритма балансировки.
Кроме того, код был написан с оглядкой на
возможную экстракцию в OCaml или Haskell;
например, тип данных, используемый для хранения,
абстрагирован через \coqinline{Int},
что позволяет при экстракции заменить его
на один из встроенных в целевой язык целочисленных типов.
Наконец, и при верификации, скажем, программы на языке C
с помощью сепарационной логики,
можно использовать предложенное доказательство
как отправную точку.

\subsection{Библиотека MSets}

Одно из немедленных преимуществ выбранного подхода --- возможность
воспользоваться стандартной библиотекой Coq, а точнее --- теорией \coqinline{MSets}.
Это набор модулей и функторов, позволяющий разрабатывать реализации абстрактного
типа данных «множество» с минимальным повторением кода\cite[functor-proofs].

К примеру, сигнатура модуля \coqinline{RawSets}
в паре с принимающим её функтором \coqinline{Raw2Sets}
позволяет сформулировать тип множества как допускающий <<плохие>> значения
(например, тип двоичного дерева, в котором нам не интересны деревья, не
являющиеся при этом деревьями поиска) и после этого перейти к его
типу-подмножеству, содержащему исключительно валидные структуры.
Это предоставит пользователю тип, с элементами которого можно работать не
опасаясь их <<порчи>>.

Ещё более полезным оказывается модуль \coqinline{MSetGenTree.Ops}, предоставляющий базу для
реализации двоичных деревьев поиска. Он определяет тип двоичного дерева,
несущего произвольную дополнительную информацию в каждом узле и реализацию всех
не-модифицирующих операций. В паре с ним предполагается применять
\coqinline{MSetGenTree.Props}, в котором определяется свойство bst (доказуемое в
точности для двоичных деревьев поиска) и инструментарий для доказательства того, что
предоставленные пользователем модифицирующие операции являются корректными
операциями на деревьях поиска (что является критерием валидности элемента
базового типа для \coqinline{RawSets}).
К примеру, в стандартной библиотеке Coq
с его помощью имплементированы АВЛ- и красно-чёрные деревья.

Верифицируемый алгоритм определяет только операции
добавляющие или удаляющие один элемент,
поэтому в работе используется копия \coqinline{MSets},
из которой удалены теоретико-множественные операции и
функции высшего порядка filter и partition.

\subsection{Проблема остановки}

При разработке на Gallina,
проблемой может оказаться требование гарантированного завершения программы ---
бесконечно работающую программу можно было бы использовать
для доказательства произвольного утверждения.
В нашем случае, вызывает трудности не само требование,
а то,как проверяется его выполнение:
в рекурсивных функциях Gallina
возможна только структурная рекурсия
по фиксированному аргументу.
То есть, должен быть зафиксирован аргумент,
для которого в любых рекурсивных вызовах
допустимы только подтермы его значения
при исходном вызове функции.
Однопроходная модификация WBT
это ограничение, очевидно, не соблюдает:
перед рекурсивным вызовом для одного из поддеревьев
может потребоваться поворот,
а повороты создают новые термы, не входящие в старое дерево,
и именно в такой терм может <<спуститься>> функция.

В подобных случаях применяется фундированная рекурсия:
из аргументов необходимо вычислить элемент некоторого множества, на котором
задан фундированный порядок. При этом необходимо добиться того, чтобы этот
элемент убывал для каждого рекурсивного вызова. Фундированный порядок требуется
формализовать по определённой схеме, а также доказать названное ранее свойство
убывания; доказательство фундированности порядка подразумевает доказательство
отсутствия бесконечных убывающих цепей от каждого элемента множества-носителя, и
эти доказательства имеют фиксированную структуру, которая вместе со
доказательствами свойства убывания убедит Coq в структурности рекурсии по этому
доказательству. Ну а в нашем случае в качестве этого убывающего элемента
подойдёт размер дерева, натуральное число, для которого возможна упрощённая
форма записи, подразумевающая в качестве фундированного порядка стандартный
порядок на \( \mathbb{N} \):

\begin{coqcode}

Function add x s {measure cardinal s} := match s with
| Leaf => singleton x
| Node _ l y r =>
  match X.compare x y with
  | Eq => s
  | Lt =>
    if boundedBy Delta (1 + weight l) (weight r)
    then node (add x l) y r
    else match l with
    | Node _ ll ly lr =>
      match X.compare x ly with
      | Eq => s
      | Lt =>
        if boundedBy Gamma (weight lr) (weight ll)
        then node (add x ll) ly (node lr y r)
        else match lr with
        | Node _ lrl lry lrr =>
          node (add x (node ll ly lrl)) lry (node lrr y r)
        | Leaf => (* impossible *) node (add x l) y r
        end
      ...
end.
all: intros; simpl; lia. Defined.

\end{coqcode}

Для доказательство убывания размера входного дерева
достаточно применить тактику \coqinline{lia} ---
решающую процедуру для бескванторной линейной арифметики
над целыми числами\cite{micromega}.
Дополнительным бонусом становится генерация схемы функциональной
индукции, о чём речь пойдёт дальше.

\clearpage
\section{Верификация алгоритма}

Верификацию модифицирующей операции можно разделить
на две независимые части:
верификация свойств общих для двоичного дерева поиска
(сохранение упорядоченности ключей и, собственно,
соответствие семантике операции изменения набора ключей)
и специфичных для деревьев, сбалансированных по весу
(корректность сохранённых данных о величине поддерева
и, конечно, сохранения сбалансированности).
Это разделение закреплено размещением
доказательств в не зависящие друг от друга функторы
\coqinline{Props} и \coqinline{BalanceProps}.

Для доказательство всех этих свойств рекурсивной функции,
конечно, хочется воспользоваться индукцией.
Однако в формальном доказательстве слово <<индукция>>
недостаточно конкретно, необходимо указать конкретную схему индукции.
Простая индукция по определению типа tree не подойдёт
по той же причине, по которой нельзя было объявить
операции как Fixpoint.
Не сработает и трюк с обобщением по размеру дерева и
последующим применением nat\_ind:
размер дерева-аргумента при рекурсивных вызовах
может уменьшаться сильнее, чем на единицу.
Необходима индукция по фундированному множеству.

К счастью, нет необходимости заглядывать в \coqinline{Coq.Init.Wf},
ведь для Function-определений генерируется схема
функциональной индукции.
Благодаря ней, тактика \coqinline{functional induction add x t}
преобразует цель из свойства \coqinline{P (add x t)}
в набор целей вида \coqinline{P res} для
всех возможных \coqinline{res},
получаемых в результате однократной замены \coqinline{add}
на её тело с последующим разбором случаев в
\coqinline{if}- и \coqinline{match}-выражениях.
В набор гипотез к каждой цели добавляются
равенства, полученные в результате разбора случаев,
и гипотезы индукций для каждого рекурсивного вызова \coqinline{add}.

В случае операции добавления элемента,
доказательство каждого из четырёх
свойств разбивается на 24 случая.
Чтобы сделать достижимыми как задачу написания доказательств,
так и их понимания,
активно используется автоматизация доказательств.

\subsection{Свойства дерева поиска}

Библиотека \coqinline{MSets} содержит
формализацию свойств двоичного дерева поиска
и несколько полезных для работы с ними тактик.
Что касается предикатов, в рамках данной работы
необходимо работать всего с несколькими,
имеющими достаточно интуитивные (и, безусловно, интуиционистские)
определения:

\begin{coqcode}
(* "ключ x присутствует в дереве" *)
Inductive InT (x : elt) : tree -> Prop :=
  | IsRoot : forall c l r y, X.eq x y
     -> InT x (Node c l y r)
  | InLeft : forall c l r y, InT x l
     -> InT x (Node c l y r)
  | InRight : forall c l r y, InT x r
     -> InT x (Node c l y r).
(* "все ключи из дерева s меньше/больше чем x" *)
Definition lt_tree x s := forall y, InT y s -> X.lt y x.
Definition gt_tree x s := forall y, InT y s -> X.lt x y.
(* "дерево является деревом поиска" *)
Inductive bst : tree -> Prop :=
  | BSLeaf : bst Leaf
  | BSNode : forall c x l r, bst l -> bst r ->
     lt_tree x l -> gt_tree x r -> bst (Node c l x r).
\end{coqcode}

Отметив, что принимаемые доказательства \coqinline{bst}
всегда абстрагируется с помощью класса предикатов %\cite{type-classes}
\coqinline{Ok},
рассмотрим лемму, формализующую семантику операции
добавления элемента в множество:
\begin{coqcode}
Lemma add_spec' : forall s x y `{Ok s},
  InT y (add x s) <-> X.eq y x \/ InT y s.
\end{coqcode}

Тут есть относительно нетривиальная
(особенно с учётом гипотез индукции)
пропозициональная структура, а потому
в качестве основы доказательства используется тактика
\coqinline{intuition}. Она базируется на решающей процедуре
для исчисления высказываний, но если для каких-то атомарных
формул не находится пропозиционального доказательства,
тактика не завершается с ошибкой, а
оставляет их для дальнейшего доказательства, 
напоследок пробуя разрешить их с помощью
\coqinline{auto with *}.

Большая часть целей, к которым сводит задачу
\coqinline{intuition},
решается комбинацией из применения конструкторов
\coqinline{InT} к одной из гипотез,
которую, возможно, необходимо извлечь
из построения \coqinline{InT}.
Применение конструкторов и гипотез
можно оставить \coqinline{auto},
а для инвертирования
индуктивных предикатов над деревьями
\coqinline{MSets} предоставляет тактику
\coqinline{invtree f}.
Не хватает этих шагов только
для случаев, когда добавляемый элемент
был обнаружен в дереве;
тут необходимо применить транзитивность
равенства, что можно легко сделать
с помощью \coqinline{eauto}.

Несколько более трудоёмким оказывается доказательство
сохранения свойства упорядоченности ключей:
\begin{coqcode}
Instance add_ok t x `(Ok t) : Ok (add x t).
\end{coqcode}

Во-первых, аналогично прошлой тактике
тут требуется конструирование и инвертирование,
но уже для предикатов
\coqinline{lt_tree} и \coqinline{gt_tree},
не определённых как индуктивные.
Леммы для конструирования определяются в \coqinline{MSets},
инвертирование всё-таки приходится реализовать:
\begin{coqcode}
Lemma lt_tree_inv : forall y s l x r,
  lt_tree y (Node s l x r) ->
  lt_tree y l /\ X.lt x y /\ lt_tree y r.
Proof. intuition; unfold lt_tree; auto. Qed.
Lemma gt_tree_inv : ...
Ltac inv_xt_tree := try match goal with
  | H : lt_tree _ (Node _ _ _ _) |- _ =>
    apply lt_tree_inv in H;
    decompose [and] H; clear H;
    inv_xt_tree
  | H : gt_tree _ (Node _ _ _ _) |- _ => ...
end.
\end{coqcode}

Во-вторых, полученных инвертированием гипотез не всегда достаточно. 
К примеру, простой правый поворот преобразует дерево
\coqinline{node (node ll ly lr) y r} в \coqinline{node ll ly (node lr y r)},
но предикат \coqinline{bst} (для исходного дерева)
в явном виде не подразумевает,
что ключи из поддерева \coqinline{r} должны быть больше \coqinline{ly},
это следует только из транзитивности отношения порядка на множестве ключей.
Такое рассуждение оформлено в лемме
\coqinline{gt_tree_trans} из \coqinline{MSets},
а после применения тактики \coqinline{inv_xt_tree}
применить эту лемму можно и без тяжеловесного \coqinline{eauto},
для поиска промежуточного ключа хватает сопоставления цели с шаблоном
\coqinline{H1 : X.lt ?x ?y, H2 : gt_tree ?y ?s |- _}.

В-третьих, предположение индукции говорит только
о выполнении предиката \coqinline{bst}
для результата рекурсивного вызова,
его использование как левого или правого поддерва требует
выполнения для него предиката \coqinline{lt_tree} или \coqinline{gt_tree},
соответственно.
На этот раз, определение этих предикатов на основе \coqinline{InT},
наоборот, удобно, поскольку это позволяет применить \coqinline{add_spec}.
Чтобы закрывать такие цели, достаточно добавить в базу подсказок \coqinline{auto}
следующую тактику:
\begin{coqcode}
Ltac xt_tree_add :=
  intro; (* unfolds head *)
  rewrite add_spec;
  [ intros [ | ]; [ | inv ] | ].
\end{coqcode}

\subsection{Сбалансированность}

Для доказательства сохранения у деревьев
свойства сбалансированности необходимо, в первую очередь,
это свойство сформулировать.
Сделать это достаточно легко,
поскольку исходное, неформальное определение,
идеально ложится на понятие индуктивных предикатов:
\begin{coqcode}
Inductive balanced (n m: nat) : tree -> Prop :=
  | BalancedLeaf : balanced n m Leaf
  | BalancedNode : forall s l x r,
      balanced n m l -> balanced n m r ->
      m * (1 + cardinal l) <= n * (1 + cardinal r) ->
      m * (1 + cardinal r) <= n * (1 + cardinal l) ->
      balanced n m (Node s l x r)
.
\end{coqcode}

Простоты ради, коэффициент \( \Delta \)
не выступает параметром напрямую,
вводится  два параметра \coqinline{n} и \coqinline{m} ---
его числитель и знаменатель.
Кроме того, при работе во вселенной \coqinline{Prop}
разумнее применять \coqinline{nat} чем \coqinline{Int};
даже определение размера множества \coqinline{cardinal}
(предоставляемое \coqinline{MSets})
имеет тип \coqinline{tree -> nat}.
Этот переход к другому типу требует небольшой технической
работы, которая скрывается в определении
предиката \coqinline{delta_balanced}
(\coqinline{balanced} с коэффициентом \( \Delta \)).

Заметим что в доказательстве утверждения сбалансированности
основную трудность представляют неравенства вида
\coqinline{a * (1 + cardinal t1) <= b * (1 + cardinal t2)}.
При этом они должны следовать из гипотез аналогичного вида, полученных
либо из условий сбалансированности входного дерева,
либо как результы сравнений, выполняемых программой
для выбора подходящего вращения.
Кроме того, если считать параметры
\( \Delta \) и \( \Gamma \)
фиксированными, то все коэффициенты \coqinline{a} и \coqinline{b}
оказываются константными,
что позволяет считать цель утверждением из арифметики Пресбургера.
Следовательно, завершить доказательство можно
с помощью тактики \coqinline{lia}.

Первый шаг на пути к главному доказательству данной работы
вряд ли описан в какой-либо публикации,
обсуждающей (неформально) корректность алгоритмов модификации
деревьев с балансировкой по весу;
по крайней мере, если корректность не доказывается
формальными методами.
Этим шагом является верификация функции \coqinline{size} ---
доказательство того, она действительно вычисляет размер дерева
(то есть, корректности дополнительной информации, хранящейся в узлах дерева).
Это тривиальное, но крайне важное условие,
ведь именно \coqinline{size} используется для принятия
решений о необходимости выполнения вращений дерева.
Весь процесс заключается в определении
чисто технического индуктивного предиката
и леммы, которая уже свзяывает значения
\coqinline{size} и \coqinline{cardinal}:
\begin{coqcode}
Inductive sizedTree : tree -> Prop :=
  | SizedLeaf : sizedTree Leaf
  | SizedNode : forall l x r,
                sizedTree l ->
                sizedTree r ->
                sizedTree (Node
                  (1 + size l + size r)
                  l x r)
Lemma size_spec : forall tr, sizedTree tr ->
  i2z (size tr) = Z.of_nat (cardinal tr).
\end{coqcode}

Доказательство леммы состоит из
аккуратного применения редукций
и тактик \coqinline{lia}
и \coqinline{i2z}
(последняя определяется в модуле
\coqinline{Int.MoreInt}
и позволяет переходить от \coqinline{Int} к \coqinline{Z}).
Благодаря тому, что \coqinline{SizedNode} просто
отражает использование в программе конструктора \coqinline{Node},
доказательство сохранения сохранения свойства
\coqinline{sizedTree} сводится к функциональной индукции
и применению для всех случаев тактик \coqinline{invtree sizedTree; auto}.
Итак, \coqinline{sizedTree} позволяет
привязать к условиям на ограниченность баланса
их семантику, для этого сформулирована тактика
\begin{coqcode}
Ltac reflect_boundedBy := lazymatch goal with
  | H : boundedBy _ _ _ = _ |- _ =>
    simpl in H;
    MI.i2z;
    rewrite ?size_spec in H;
    [ simpl_boundedBy | assumption.. ]
  | _ => idtac
end.
\end{coqcode}

Ещё одно очевидное свойство, которое необходимо доказать,
касается влияния операций на размер дерева.
Так, \coqinline{add} либо сохранит его
(если ключ уже есть), либо увеличит его на единицу.
Опять же, доказательство состоит из индукции,
упрощения сравниваемых термов и
доказательства тривиального равенства с помощью \coqinline{lia}.
Для применения этого свойства используется тактика
\begin{coqcode}
Ltac rw_add_cardinal := match goal with
  | |- context [cardinal (add ?x ?tr)] =>
    let H := fresh in
    destruct (add_cardinal tr x) as [H | H];
    rewrite H
end.
\end{coqcode}

После всей этой подготовительной работы,
изложенная выше идея доказательства
достаточно кратко выражается в Coq'е:
\begin{coqcode}
Hint Constructors balanced : core.
Hint Extern 8 => rewrite cardinal_node in * : core.
Hint Extern 9 => rw_add_cardinal : core.
Hint Extern 10 => lia : core.
Theorem add_balanced : forall t x,
  sizedTree t -> delta_balanced t ->
  delta_balanced (add x t).
Proof.
  intros t x Hsize Hbalance.
  functional induction add x t;
  try apply singleton_balanced;
  unfold_helpers; unfold_delta;
  invtree balanced; invtree sizedTree;
  reflect_boundedBy;
  auto 6.
Qed.
\end{coqcode}

\clearpage
\section{О выборе параметров}

При использовании сбалансированных по весу деревьев
важную роль играет выбор параметров \( \Delta \) и \( \Gamma \).
Чем меньше их значения,
тем сильнее сбалансированно дерево
и меньше его глубина,
что напрямую влияет на время работы всех операций;
с другой стороны,
возрастает и количество необходимых вращений,
что приводит к замедлению вставки и удаления ключей.
При этом не для всех значений параметров
алгоритм работает корректно.
Для однопроходной версии известно только о
допустимости множества
\( \{ \langle \Delta, \Gamma \rangle \mid
\text{$3 \leqslant \Delta \leqslant 4,5$
и $\Delta \cdot \Gamma = 1 + \Delta$} \} \)\cite{lai}. 


Даже вид самих чисел может иметь существенное значение;
например, оптимальным
с точки зрения сбалансированности дерева является
набор \( \langle 1 + \sqrt{2}, \sqrt{2} \rangle \),
но иррациональность коэффициентов
делает его непрактичным\cite{roura}.
Наоборот,
единственный допустимый целочисленный набор \( \langle 3, 2 \rangle \)
позволяет при сравнениях размеров поддеревьев
использовать одну операцию умножения,
а не две, как для рациональных параметров.

В итоге, единственным разумным способом
подобрать оптимальный набор параметров
является эмпирическая оценка производительности.
Для двухпроходного алгоритма,
большое влияние оказала работа Адамса\cite{adams},
в которой рекомендуется использовать
значения \( \Delta \) не меньше четырёх.
Для однопроходного варианта
можно опираться на результаты полученные
Бартом и Вагнер для модифицирующих операций\cite{barth}.
Они проводили замеры для следующих наборов параметров:
\( \langle 3, 4/3 \rangle \)
(единственный доказанно корректный вариант),
\( \langle 1 + \sqrt{2}, 2 \rangle \) и
\( \langle 3, 2 \rangle \)
(доказанно корректных для двухпроходного алгоритма),
\( \langle 2, 3/2 \rangle \) и
\( \langle 3/2, 5/4 \rangle \)
(гарантированно некорректных).
Исходя из совокупности синтетических тестов,
наиболее практичными
оказались \( \langle 3, 4/3 \rangle \),
\( \langle 3, 2 \rangle \)
и, несмотря на значительное количество несбалансированных узлов,
\( \langle 2, 3/2 \rangle \).
В случае использования реальных тестовых данных
(последовательность операций в алгоритме SWAG\cite{swag}),
оптимальным оказался набор \( \langle 3, 2 \rangle \).

Исходя из потенциальной практической применимости,
в рамках данной работы 
функтор \coqinline{BalanceProps} был применён
для параметров
\( \langle 3, 4/3 \rangle \), \( \langle 3, 2 \rangle \)
и \( \langle 2, 3/2 \rangle \).
Проверка доказательства успешно выполнилась
для пар \( \langle 3, 4/3 \rangle \)
и \( \langle 3, 2 \rangle \),
а для \( \langle 2, 3/2 \rangle \),
ожидаемо, завершилась ошибкой.
Как уже было сказано ранее,
только для \( \langle 3, 4/3 \rangle \) 
доказательство корректности было опубликовано ранее.
Таким образом, корректность
однопроходной вставки элементов
для набора параметров \( \langle 3, 2 \rangle \)
является новым результатом.

\clearpage
\anonsection{Заключение}

В рамках работы был успешно реализован и верифицирован алгоритм однопроходной
вставки для деревьев с балансировкой по весу,
код доступен по адресу \url{https://github.com/mizabrik/verified-top-down-wbt}.
Представленное доказательство проверено для некоторых практически значимых наборов параметров,
и есть основания полагать, что оно подходит для любого допустимого набора параметров.
В процессе доказательства активно использовалась автоматизация,
и некоторые тактики могут быть полезны для дальнейшего анализа свойств WBT.
 доступен на GitHub
по адресу 

Полученные результаты результаты
являются аналогом таковых у Нипкова и Дирикса\cite{nipkow},
но для однопроходной версии алгоритма.

Возможности направлениями дальнейшей работы являются,
в порядке возрастания амбициозности:
\begin{itemize}
  \item Верификация функции удаления элемента;
  \item Достижение работоспособной экстракции в OCaml или Haskell;
  \item Формализация доказательства допустимости множества параметров,
    предъявленного Лэем и Вудом;
  \item Аналогично работе Хираи и Ямамото, определение множества допустимых
    параметров.
\end{itemize}

\clearpage
%\anonsection{Список литературы}
\printbibliography%[heading=none]

\end{document}
